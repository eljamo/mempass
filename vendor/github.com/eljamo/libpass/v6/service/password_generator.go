package service

import (
	"errors"
	"fmt"
	"sync"

	"github.com/eljamo/libpass/v6/config"
)

// PasswordGeneratorService defines the interface for a service that generates
// passwords. It requires an implementation of the Generate method that returns
// a slice of strings representing generated passwords and an error if the
// generation process fails.
type PasswordGeneratorService interface {
	// Generate creates a list of passwords and returns the list or an error
	Generate() ([]string, error)
}

// DefaultPasswordGeneratorService implements the PasswordGeneratorService
// interface providing a concrete implementation for password generation. It
// combines various services like transformers, separators, padders, and word
// list services to generate passwords based on provided configuration.
type DefaultPasswordGeneratorService struct {
	cfg            *config.Settings
	transformerSvc TransformerService
	separatorSvc   SeparatorService
	paddingSvc     PaddingService
	wordListSvc    WordListService
}

// NewCustomPasswordGeneratorService constructs a new instance of
// DefaultPasswordGeneratorService with the provided services and
// configuration. It validates the configuration and returns an
// error if the configuration is invalid (e.g., number of passwords
// is less than 1).
func NewCustomPasswordGeneratorService(
	cfg *config.Settings,
	transformerSvc TransformerService,
	separatorSvc SeparatorService,
	paddingSvc PaddingService,
	wordListSvc WordListService,
) (*DefaultPasswordGeneratorService, error) {
	np := cfg.NumPasswords
	if np < 1 {
		return nil, errors.New("num_passwords must be greater than 0")
	}

	return &DefaultPasswordGeneratorService{
		cfg,
		transformerSvc,
		separatorSvc,
		paddingSvc,
		wordListSvc,
	}, nil
}

// NewPasswordGeneratorService constructs a DefaultPasswordGeneratorService with default
// implementations for its dependent services (transformer, separator, padding, and word list services).
// It initializes each service with the provided configuration and random number generator service.
func NewPasswordGeneratorService(
	cfg *config.Settings,
) (*DefaultPasswordGeneratorService, error) {

	rngs := NewRNGService()
	wls, err := NewWordListService(cfg, rngs)
	if err != nil {
		return nil, err
	}

	ts, err := NewTransformerService(cfg, rngs)
	if err != nil {
		return nil, err
	}

	ss, err := NewSeparatorService(cfg, rngs)
	if err != nil {
		return nil, err
	}

	ps, err := NewPaddingService(cfg, rngs)
	if err != nil {
		return nil, err
	}

	return NewCustomPasswordGeneratorService(cfg, ts, ss, ps, wls)
}

// Generate creates a list of passwords using the services provided to the
// DefaultPasswordGeneratorService instance and returns the list of generated
// passwords or the first error if one or more is encountered.
func (s *DefaultPasswordGeneratorService) Generate() ([]string, error) {
	np := s.cfg.NumPasswords

	var wg sync.WaitGroup
	wg.Add(np) // Set the number of goroutines to wait for.

	pws := make([]string, np)
	errChan := make(chan error, np) // Channel to capture errors from goroutines

	for i := 0; i < np; i++ {
		go func(i int) { // Launch a goroutine for each password generation.
			defer wg.Done() // Signal completion of the goroutine at the end

			// Get a list of words from the wordList service
			sl, err := s.wordListSvc.GetWords()
			if err != nil {
				errChan <- err // Send any errors to the error channel
				return
			}

			// Transform the casing of words or letters using the transformer service
			slt, err := s.transformerSvc.Transform(sl)
			if err != nil {
				errChan <- err
				return
			}

			// Separate the transformed list using the separator service using special characters
			sls, err := s.separatorSvc.Separate(slt)
			if err != nil {
				errChan <- err
				return
			}

			// Pad the password with digits and special characters using the padding service
			pw, err := s.paddingSvc.Pad(sls)
			if err != nil {
				errChan <- err
				return
			}

			pws[i] = pw
		}(i)
	}

	wg.Wait()      // Wait for all goroutines to complete
	close(errChan) // Close the error channel

	// Check if there were any errors generated by the goroutines
	if len(errChan) > 0 {
		return nil, fmt.Errorf("%w", <-errChan) // Return the first error encountered
	}

	return pws, nil
}
